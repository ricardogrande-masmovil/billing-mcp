package persistence

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/ricardogrande-masmovil/billing-mcp/internal/movements/domain"
	domainmodel "github.com/ricardogrande-masmovil/billing-mcp/internal/movements/domain/model"
	"github.com/ricardogrande-masmovil/billing-mcp/internal/movements/infrastructure/persistence/sql"
	"github.com/rs/zerolog"
)

// MovementSQLRepository implements the domain.MovementRepository interface using SQL.
// It uses a sql.MovementSqlClient to interact with the database.
type MovementSQLRepository struct {
	client    *sql.MovementSqlClient
	converter *sql.MovementConverter
	logger    zerolog.Logger
}

// NewMovementSQLRepository creates a new MovementSQLRepository.
func NewMovementSQLRepository(client *sql.MovementSqlClient, converter *sql.MovementConverter, logger zerolog.Logger) domain.MovementRepository {
	return &MovementSQLRepository{
		client:    client,
		converter: converter,
		logger:    logger.With().Str("component", "MovementSQLRepository").Logger(),
	}
}

// Create persists a new movement.
func (r *MovementSQLRepository) Create(ctx context.Context, movement *domainmodel.Movement) error {
	r.logger.Debug().Interface("domainMovement", movement).Msg("Creating movement")
	sqlMovement := r.converter.ToSQLMovement(movement)
	err := r.client.CreateMovement(ctx, sqlMovement)
	if err != nil {
		r.logger.Error().Err(err).Msg("Failed to create movement in repository")
		return fmt.Errorf("repository: failed to create movement: %w", err)
	}
	// Update the domain model with any DB-generated fields (like ID if not set, or CreatedAt/UpdatedAt)
	// This step is crucial if the domain model needs to reflect the state from the DB post-creation.
	// For example, if sqlMovement.ID is generated by the DB:
	// movement.MovementID = sqlMovement.ID
	// movement.CreatedAt = sqlMovement.CreatedAt
	// movement.UpdatedAt = sqlMovement.UpdatedAt
	r.logger.Info().Msg("Movement created successfully in repository")
	return nil
}

// GetByID retrieves a movement by its ID.
func (r *MovementSQLRepository) GetByID(ctx context.Context, id uuid.UUID) (*domainmodel.Movement, error) {
	r.logger.Debug().Stringer("movementID", id).Msg("Getting movement by ID")
	sqlMovement, err := r.client.GetMovementByID(ctx, id)
	if err != nil {
		r.logger.Warn().Err(err).Stringer("movementID", id).Msg("Failed to get movement by ID from client")
		return nil, fmt.Errorf("repository: failed to get movement by ID %s: %w", id, err)
	}
	if sqlMovement == nil {
		return nil, domain.ErrMovementNotFound // Or a more specific error from domain
	}
	r.logger.Info().Stringer("movementID", id).Msg("Movement retrieved successfully from repository")
	return r.converter.ToDomainMovement(sqlMovement), nil
}

// Update updates an existing movement (specifically its status).
func (r *MovementSQLRepository) Update(ctx context.Context, movement *domainmodel.Movement) error {
	r.logger.Debug().Interface("domainMovement", movement).Msg("Updating movement")
	sqlMovement := r.converter.ToSQLMovement(movement)
	err := r.client.UpdateMovement(ctx, sqlMovement)
	if err != nil {
		r.logger.Error().Err(err).Stringer("movementID", movement.MovementID).Msg("Failed to update movement in repository")
		return fmt.Errorf("repository: failed to update movement with ID %s: %w", movement.MovementID, err)
	}
	r.logger.Info().Stringer("movementID", movement.MovementID).Msg("Movement updated successfully in repository")
	return nil
}

// Delete removes a movement by its ID.
func (r *MovementSQLRepository) Delete(ctx context.Context, id uuid.UUID) error {
	r.logger.Debug().Stringer("movementID", id).Msg("Deleting movement")
	err := r.client.DeleteMovement(ctx, id)
	if err != nil {
		r.logger.Error().Err(err).Stringer("movementID", id).Msg("Failed to delete movement in repository")
		return fmt.Errorf("repository: failed to delete movement with ID %s: %w", id, err)
	}
	r.logger.Info().Stringer("movementID", id).Msg("Movement deleted successfully from repository")
	return nil
}

// Search retrieves movements based on criteria.
func (r *MovementSQLRepository) Search(ctx context.Context, criteria *domainmodel.SearchCriteria) ([]*domainmodel.Movement, error) {
	r.logger.Debug().Interface("criteria", criteria).Msg("Searching movements")
	sqlMovements, err := r.client.SearchMovements(ctx, criteria)
	if err != nil {
		r.logger.Error().Err(err).Msg("Failed to search movements in repository")
		return nil, fmt.Errorf("repository: failed to search movements: %w", err)
	}

	domainMovements := make([]*domainmodel.Movement, len(sqlMovements))
	for i, sm := range sqlMovements {
		domainMovements[i] = r.converter.ToDomainMovement(&sm) // Pass pointer if ToDomainMovement expects it
	}
	r.logger.Info().Int("count", len(domainMovements)).Msg("Movements search completed in repository")
	return domainMovements, nil
}
